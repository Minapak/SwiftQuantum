//
//  QuantumGates.swift
//  SwiftQuantum
//
//  Created by Eunmin Park on 2025-09-22.
//  Copyright © 2025 iOS Quantum Engineering. All rights reserved.
//

import Foundation

// MARK: - Linear Algebra: Quantum Gates as Matrix Transformations
//
// Quantum gates are unitary matrices that transform qubit states.
// This demonstrates the deep connection between linear algebra and quantum computing.
//
// Key Linear Algebra Concepts:
//
// 1. Matrix-Vector Multiplication
//    - Gate operation: |ψ'⟩ = U|ψ⟩ where U is a 2×2 unitary matrix
//    - Transforms state vector while preserving norm
//
// 2. Unitary Matrices (U†U = I)
//    - Preserve inner products: ⟨Uψ|Uφ⟩ = ⟨ψ|φ⟩
//    - Preserve normalization: ||U|ψ⟩|| = ||ψ||
//    - Reversible: U† = U⁻¹
//
// 3. Eigenvalues and Eigenvectors
//    - Computational basis {|0⟩, |1⟩} are often eigenvectors
//    - Eigenvalues have unit magnitude (|λ| = 1)
//    - Phase gates add eigenvalue phases
//
// 4. Matrix Composition
//    - Sequential gates: U₂(U₁|ψ⟩) = (U₂U₁)|ψ⟩
//    - Matrix multiplication is associative
//
// 5. Special Unitary Group SU(2)
//    - All single-qubit gates form SU(2) group
//    - Generated by: Pauli matrices + rotations
//    - Universal: Any U ∈ SU(2) = Rz(α)Ry(β)Rz(γ)
//
// Educational Resource:
// For visual understanding of matrix transformations and linear maps:
// https://eunminpark.hashnode.dev/reviews-linear-algebra-through-three-lenses-an-ios-developers-journey-with-3blue1brown
//
// Matrix Notation:
// Each gate U acts on state vector |ψ⟩ = [α, β]ᵀ:
//
//     [U₀₀  U₀₁] [α]   [U₀₀α + U₀₁β]
//     [U₁₀  U₁₁] [β] = [U₁₀α + U₁₁β]

/// Collection of fundamental quantum gates for single-qubit operations
///
/// Quantum gates are the building blocks of quantum circuits, representing
/// unitary operations that transform qubit states. This struct provides
/// implementations of the most commonly used single-qubit gates.
///
/// ## Mathematical Background
/// All quantum gates are represented as 2×2 unitary matrices that operate
/// on the complex amplitudes of a qubit state vector.
///
/// ## Example Usage
/// ```swift
/// let qubit = Qubit.zero
/// let superposition = QuantumGates.hadamard(qubit)
/// let rotated = QuantumGates.rotationZ(qubit, angle: .pi/4)
/// ```
public struct QuantumGates {
    
    // MARK: - Pauli Gates
    
    /// Pauli-X Gate (Quantum NOT Gate)
    ///
    /// Flips the qubit state: |0⟩ ↔ |1⟩
    ///
    /// Linear Algebra: Permutation matrix (swaps basis vectors)
    /// Matrix representation:
    /// ```
    /// X = |0  1| = σₓ (Pauli matrix X)
    ///     |1  0|
    /// ```
    /// Effect on basis:
    /// - X|0⟩ = |1⟩ (swaps first and second components)
    /// - X|1⟩ = |0⟩
    ///
    /// Properties:
    /// - Hermitian: X† = X (self-adjoint)
    /// - Unitary: X†X = I
    /// - Involutory: X² = I (self-inverse)
    /// - Eigenvalues: {+1, -1}
    /// - Eigenvectors: |±⟩ = (|0⟩ ± |1⟩)/√2
    ///
    /// - Parameter qubit: Input qubit state
    /// - Returns: Qubit with flipped amplitudes
    public static func pauliX(_ qubit: Qubit) -> Qubit {
        // Linear Algebra: Matrix-vector multiplication
        // [0 1][α] = [β]
        // [1 0][β]   [α]
        return Qubit(
            amplitude0: qubit.amplitude1,
            amplitude1: qubit.amplitude0
        )
    }
    
    /// Pauli-Y Gate
    ///
    /// Rotates the qubit around the Y-axis of the Bloch sphere
    ///
    /// Linear Algebra: Rotation matrix with imaginary components
    /// Matrix representation:
    /// ```
    /// Y = |0  -i| = σᵧ (Pauli matrix Y)
    ///     |i   0|
    /// ```
    /// Effect:
    /// - Y|0⟩ = i|1⟩ (rotation + phase)
    /// - Y|1⟩ = -i|0⟩
    ///
    /// Properties:
    /// - Hermitian: Y† = Y
    /// - Unitary: Y†Y = I
    /// - Involutory: Y² = I
    /// - Anti-commutes with X and Z
    ///
    /// - Parameter qubit: Input qubit state
    /// - Returns: Y-rotated qubit state
    public static func pauliY(_ qubit: Qubit) -> Qubit {
        // Linear Algebra: Matrix-vector multiplication with complex entries
        // [0  -i][α] = [-iβ]
        // [i   0][β]   [iα]
        return Qubit(
            amplitude0: Complex(0.0, -1.0) * qubit.amplitude1,
            amplitude1: Complex(0.0, 1.0) * qubit.amplitude0
        )
    }
    
    /// Pauli-Z Gate (Phase Flip Gate)
    ///
    /// Applies a phase flip to the |1⟩ component
    ///
    /// Linear Algebra: Diagonal matrix (eigenvalue matrix)
    /// Matrix representation:
    /// ```
    /// Z = |1   0| = σᵤ (Pauli matrix Z)
    ///     |0  -1|
    /// ```
    /// Effect:
    /// - Z|0⟩ = +|0⟩ (eigenvalue +1)
    /// - Z|1⟩ = -|1⟩ (eigenvalue -1)
    ///
    /// Properties:
    /// - Diagonal in computational basis
    /// - Basis states are eigenvectors
    /// - Hermitian and Unitary
    /// - Involutory: Z² = I
    ///
    /// Bloch sphere: Rotates π radians around Z-axis
    ///
    /// - Parameter qubit: Input qubit state
    /// - Returns: Phase-flipped qubit state
    public static func pauliZ(_ qubit: Qubit) -> Qubit {
        // Linear Algebra: Diagonal matrix multiplication
        // [1   0][α] = [ α]
        // [0  -1][β]   [-β]
        return Qubit(
            amplitude0: qubit.amplitude0,
            amplitude1: -qubit.amplitude1
        )
    }
    
    // MARK: - Hadamard Gate
    
    /// Hadamard Gate
    ///
    /// Creates equal superposition from basis states:
    /// - |0⟩ → (|0⟩ + |1⟩)/√2
    /// - |1⟩ → (|0⟩ - |1⟩)/√2
    ///
    /// Linear Algebra: Orthogonal matrix (rotation + reflection)
    /// Matrix representation:
    /// ```
    /// H = (1/√2) |1   1| = (X + Z)/√2
    ///            |1  -1|
    /// ```
    ///
    /// Properties:
    /// - Hermitian: H† = H (self-adjoint)
    /// - Unitary: H†H = I
    /// - Involutory: H² = I (self-inverse)
    /// - Changes basis: computational ↔ Hadamard basis
    /// - Eigenvalues: {+1, -1}
    ///
    /// Geometric interpretation:
    /// - Rotates Bloch sphere 180° around axis (X+Z)/√2
    /// - Maps Z-axis to X-axis and vice versa
    ///
    /// Basis transformation:
    /// - |0⟩ → |+⟩, |1⟩ → |−⟩ (to Hadamard basis)
    /// - |+⟩ → |0⟩, |−⟩ → |1⟩ (to computational basis)
    ///
    /// - Parameter qubit: Input qubit state
    /// - Returns: Qubit in superposition state
    public static func hadamard(_ qubit: Qubit) -> Qubit {
        // Linear Algebra: Matrix-vector multiplication with normalization
        // (1/√2)[1   1][α] = (1/√2)[α + β]
        //       [1  -1][β]          [α - β]
        let factor = 1.0 / sqrt(2.0)
        
        let newAmplitude0 = factor * (qubit.amplitude0 + qubit.amplitude1)
        let newAmplitude1 = factor * (qubit.amplitude0 - qubit.amplitude1)
        
        return Qubit(
            amplitude0: newAmplitude0,
            amplitude1: newAmplitude1
        )
    }
    
    // MARK: - Phase Gates
    
    /// S Gate (Phase Gate)
    ///
    /// Applies a π/2 phase shift to the |1⟩ component
    ///
    /// Linear Algebra: Diagonal unitary matrix
    /// Matrix representation:
    /// ```
    /// S = |1  0| = diag(1, i) = √Z
    ///     |0  i|
    /// ```
    ///
    /// Properties:
    /// - Unitary: S†S = I
    /// - S² = Z (square root of Pauli-Z)
    /// - S† = S⁻¹ = diag(1, -i)
    /// - Diagonal: acts independently on each basis state
    ///
    /// Effect:
    /// - S|0⟩ = |0⟩ (no change)
    /// - S|1⟩ = i|1⟩ (π/2 phase)
    /// - S|+⟩ = |i⟩ (adds relative phase)
    ///
    /// Bloch sphere: Rotates π/2 around Z-axis
    ///
    /// - Parameter qubit: Input qubit state
    /// - Returns: Phase-shifted qubit state
    public static func sGate(_ qubit: Qubit) -> Qubit {
        // Linear Algebra: Diagonal matrix multiplication
        // [1  0][α] = [α ]
        // [0  i][β]   [iβ]
        return Qubit(
            amplitude0: qubit.amplitude0,
            amplitude1: Complex.i * qubit.amplitude1
        )
    }
    
    /// S† Gate (S-dagger, inverse of S gate)
    ///
    /// Applies a -π/2 phase shift to the |1⟩ component
    ///
    /// Linear Algebra: Conjugate transpose (adjoint) of S gate
    /// Matrix representation:
    /// ```
    /// S† = |1   0| = diag(1, -i) = S⁻¹
    ///      |0  -i|
    /// ```
    ///
    /// Properties:
    /// - S†S = SS† = I (inverse relation)
    /// - Unitary adjoint
    /// - (S†)² = Z†= Z
    ///
    /// Bloch sphere: Rotates -π/2 around Z-axis
    ///
    /// - Parameter qubit: Input qubit state
    /// - Returns: Inverse phase-shifted qubit state
    public static func sDagger(_ qubit: Qubit) -> Qubit {
        // Linear Algebra: Adjoint matrix application
        // [1   0][α] = [α  ]
        // [0  -i][β]   [-iβ]
        return Qubit(
            amplitude0: qubit.amplitude0,
            amplitude1: Complex.minusI * qubit.amplitude1
        )
    }
    
    /// T Gate (π/8 Gate)
    ///
    /// Applies a π/4 phase shift to the |1⟩ component
    ///
    /// Linear Algebra: Diagonal phase matrix
    /// Matrix representation:
    /// ```
    /// T = |1    0   | = diag(1, e^(iπ/4)) = √S
    ///     |0  e^(iπ/4)|
    /// ```
    ///
    /// Properties:
    /// - T² = S (T is fourth root of Z)
    /// - T⁴ = Z
    /// - T⁸ = I
    /// - Part of Clifford+T universal gate set
    ///
    /// Universality: T gate + Clifford gates = universal quantum computing
    ///
    /// Bloch sphere: Rotates π/4 around Z-axis
    ///
    /// - Parameter qubit: Input qubit state
    /// - Returns: T-gate transformed qubit state
    public static func tGate(_ qubit: Qubit) -> Qubit {
        // Linear Algebra: Diagonal matrix with complex exponential
        // [1        0     ][α] = [α            ]
        // [0  e^(iπ/4)][β]   [e^(iπ/4)β]
        let phase = Complex.exp(Complex(0.0, .pi / 4))
        
        return Qubit(
            amplitude0: qubit.amplitude0,
            amplitude1: phase * qubit.amplitude1
        )
    }
    
    /// T† Gate (T-dagger, inverse of T gate)
    ///
    /// Applies a -π/4 phase shift to the |1⟩ component
    ///
    /// Linear Algebra: Adjoint of T gate
    /// Matrix representation:
    /// ```
    /// T† = |1     0    | = diag(1, e^(-iπ/4)) = T⁻¹
    ///      |0  e^(-iπ/4)|
    /// ```
    ///
    /// Properties:
    /// - T†T = TT† = I (inverse)
    /// - (T†)² = S†
    /// - (T†)⁴ = Z
    ///
    /// - Parameter qubit: Input qubit state
    /// - Returns: Inverse T-gate transformed qubit state
    public static func tDagger(_ qubit: Qubit) -> Qubit {
        // Linear Algebra: Adjoint application
        // [1         0     ][α] = [α             ]
        // [0  e^(-iπ/4)][β]   [e^(-iπ/4)β]
        let phase = Complex.exp(Complex(0.0, -.pi / 4))
        
        return Qubit(
            amplitude0: qubit.amplitude0,
            amplitude1: phase * qubit.amplitude1
        )
    }
    
    // MARK: - Rotation Gates
    
    /// Rotation around X-axis (RX Gate)
    ///
    /// Rotates the qubit state around the X-axis of the Bloch sphere
    ///
    /// Linear Algebra: Matrix exponential of Pauli-X
    /// RX(θ) = exp(-iθX/2) = cos(θ/2)I - i·sin(θ/2)X
    ///
    /// Matrix representation:
    /// ```
    /// RX(θ) = |cos(θ/2)  -i·sin(θ/2)|
    ///         |-i·sin(θ/2)  cos(θ/2)|
    /// ```
    ///
    /// Properties:
    /// - Unitary: RX(θ)†RX(θ) = I
    /// - Continuous rotation (θ ∈ ℝ)
    /// - RX(0) = I (identity)
    /// - RX(π) = -iX (Pauli-X up to phase)
    /// - RX(-θ) = RX(θ)† (inverse)
    ///
    /// Effect: Rotates state vector θ radians around X-axis in Bloch sphere
    ///
    /// - Parameters:
    ///   - qubit: Input qubit state
    ///   - angle: Rotation angle in radians
    /// - Returns: X-rotated qubit state
    public static func rotationX(_ qubit: Qubit, angle: Double) -> Qubit {
        // Linear Algebra: Matrix-vector multiplication for rotation
        // Uses Rodrigues' rotation formula in complex space
        let cos_half = cos(angle / 2.0)
        let sin_half = sin(angle / 2.0)
        let minus_i_sin = Complex(0.0, -sin_half)
        
        // [cos(θ/2)    -i·sin(θ/2)][α]
        // [-i·sin(θ/2)   cos(θ/2) ][β]
        let newAmplitude0 = Complex(cos_half, 0.0) * qubit.amplitude0 + minus_i_sin * qubit.amplitude1
        let newAmplitude1 = minus_i_sin * qubit.amplitude0 + Complex(cos_half, 0.0) * qubit.amplitude1
        
        return Qubit(
            amplitude0: newAmplitude0,
            amplitude1: newAmplitude1
        )
    }
    
    /// Rotation around Y-axis (RY Gate)
    ///
    /// Rotates the qubit state around the Y-axis of the Bloch sphere
    ///
    /// Linear Algebra: Matrix exponential of Pauli-Y
    /// RY(θ) = exp(-iθY/2) = cos(θ/2)I - i·sin(θ/2)Y
    ///
    /// Matrix representation:
    /// ```
    /// RY(θ) = |cos(θ/2)  -sin(θ/2)|
    ///         |sin(θ/2)   cos(θ/2)|
    /// ```
    ///
    /// Properties:
    /// - Real matrix (no imaginary components)
    /// - Orthogonal rotation matrix
    /// - RY(0) = I
    /// - RY(π) = iY
    /// - RY(π/2): |0⟩ → (|0⟩+|1⟩)/√2
    ///
    /// Note: Most "natural" rotation (real matrix, like classical rotation)
    ///
    /// - Parameters:
    ///   - qubit: Input qubit state
    ///   - angle: Rotation angle in radians
    /// - Returns: Y-rotated qubit state
    public static func rotationY(_ qubit: Qubit, angle: Double) -> Qubit {
        // Linear Algebra: Real orthogonal matrix multiplication
        // Standard 2D rotation matrix form
        let cos_half = cos(angle / 2.0)
        let sin_half = sin(angle / 2.0)
        
        // [cos(θ/2)  -sin(θ/2)][α]
        // [sin(θ/2)   cos(θ/2)][β]
        let newAmplitude0 = Complex(cos_half, 0.0) * qubit.amplitude0 + Complex(-sin_half, 0.0) * qubit.amplitude1
        let newAmplitude1 = Complex(sin_half, 0.0) * qubit.amplitude0 + Complex(cos_half, 0.0) * qubit.amplitude1
        
        return Qubit(
            amplitude0: newAmplitude0,
            amplitude1: newAmplitude1
        )
    }
    
    /// Rotation around Z-axis (RZ Gate)
    ///
    /// Rotates the qubit state around the Z-axis of the Bloch sphere
    ///
    /// Linear Algebra: Diagonal phase matrix
    /// RZ(θ) = exp(-iθZ/2) = diag(e^(-iθ/2), e^(iθ/2))
    ///
    /// Matrix representation:
    /// ```
    /// RZ(θ) = |e^(-iθ/2)     0    |
    ///         |    0     e^(iθ/2)|
    /// ```
    ///
    /// Properties:
    /// - Diagonal matrix (phase rotation)
    /// - RZ(0) = I (up to global phase)
    /// - RZ(π) = iZ
    /// - RZ(π/2) = iS
    /// - Adds relative phase between |0⟩ and |1⟩
    ///
    /// Effect: Rotates phase in XY-plane of Bloch sphere
    /// Does not change |α|² or |β|² (only relative phase)
    ///
    /// - Parameters:
    ///   - qubit: Input qubit state
    ///   - angle: Rotation angle in radians
    /// - Returns: Z-rotated qubit state
    public static func rotationZ(_ qubit: Qubit, angle: Double) -> Qubit {
        // Linear Algebra: Diagonal matrix with complex exponentials
        // Multiplies by phase factors: e^(±iθ/2)
        let phase_minus = Complex.exp(Complex(0.0, -angle / 2.0))
        let phase_plus = Complex.exp(Complex(0.0, angle / 2.0))
        
        // [e^(-iθ/2)     0     ][α] = [e^(-iθ/2)α]
        // [    0     e^(iθ/2)][β]   [e^(iθ/2)β]
        return Qubit(
            amplitude0: phase_minus * qubit.amplitude0,
            amplitude1: phase_plus * qubit.amplitude1
        )
    }
    
    // MARK: - Arbitrary Single-Qubit Gates
    
    /// Universal single-qubit gate (U3 Gate)
    ///
    /// Most general single-qubit unitary operation, parameterized by three angles
    ///
    /// Linear Algebra: General SU(2) matrix decomposition
    /// Any unitary U ∈ SU(2) can be written as:
    /// U3(θ,φ,λ) = RZ(φ)·RY(θ)·RZ(λ) (ZYZ decomposition)
    ///
    /// Matrix representation:
    /// ```
    /// U3(θ,φ,λ) = |cos(θ/2)           -e^(iλ)·sin(θ/2)    |
    ///             |e^(iφ)·sin(θ/2)    e^(i(φ+λ))·cos(θ/2)|
    /// ```
    ///
    /// Properties:
    /// - Universal: Any single-qubit gate = U3(θ,φ,λ) for some angles
    /// - det(U3) = 1 (special unitary)
    /// - Three degrees of freedom (SU(2) is 3D group)
    ///
    /// Special cases:
    /// - U3(0,0,0) = I (identity)
    /// - U3(π,0,π) = X (Pauli-X)
    /// - U3(π,π/2,π/2) = Y (Pauli-Y)
    /// - U3(0,0,λ) = RZ(λ) (Z-rotation)
    /// - U3(θ,0,0) = RY(θ) (Y-rotation)
    ///
    /// - Parameters:
    ///   - qubit: Input qubit state
    ///   - theta: Rotation angle θ (polar angle)
    ///   - phi: Phase angle φ (azimuthal phase)
    ///   - lambda: Phase angle λ (basis phase)
    /// - Returns: Transformed qubit state
    public static func u3Gate(_ qubit: Qubit, theta: Double, phi: Double, lambda: Double) -> Qubit {
        // Linear Algebra: General unitary matrix multiplication
        // Combines rotation (θ) and phase shifts (φ, λ)
        let cos_half = cos(theta / 2.0)
        let sin_half = sin(theta / 2.0)
        
        // Calculate phase factors using Euler's formula
        let exp_phi = Complex.exp(Complex(0.0, phi))
        let exp_lambda = Complex.exp(Complex(0.0, lambda))
        let exp_phi_lambda = Complex.exp(Complex(0.0, phi + lambda))
        
        // Matrix-vector multiplication:
        // [cos(θ/2)            -e^(iλ)sin(θ/2)    ][α]
        // [e^(iφ)sin(θ/2)    e^(i(φ+λ))cos(θ/2)][β]
        let newAmplitude0 = Complex(cos_half, 0.0) * qubit.amplitude0 +
                           (-exp_lambda * sin_half) * qubit.amplitude1
        
        let newAmplitude1 = (exp_phi * sin_half) * qubit.amplitude0 +
                           (exp_phi_lambda * cos_half) * qubit.amplitude1
        
        return Qubit(
            amplitude0: newAmplitude0,
            amplitude1: newAmplitude1
        )
    }
    
    /// Phase Gate with arbitrary angle
    ///
    /// Applies a phase shift of angle φ to the |1⟩ component
    ///
    /// Linear Algebra: Diagonal phase matrix
    /// Matrix representation:
    /// ```
    /// P(φ) = |1    0   | = diag(1, e^(iφ))
    ///        |0  e^(iφ)|
    /// ```
    ///
    /// Properties:
    /// - Diagonal (acts independently on basis states)
    /// - P(0) = I
    /// - P(π/2) = S
    /// - P(π/4) = T
    /// - P(π) = Z
    /// - P(φ)P(ψ) = P(φ+ψ) (phases add)
    ///
    /// Effect: Adds relative phase between |0⟩ and |1⟩ components
    ///
    /// - Parameters:
    ///   - qubit: Input qubit state
    ///   - angle: Phase angle in radians
    /// - Returns: Phase-shifted qubit state
    public static func phaseGate(_ qubit: Qubit, angle: Double) -> Qubit {
        // Linear Algebra: Diagonal matrix with unit magnitude eigenvalues
        // Multiplies |1⟩ component by e^(iφ)
        let phase = Complex.exp(Complex(0.0, angle))
        
        // [1     0  ][α] = [α    ]
        // [0  e^(iφ)][β]   [e^(iφ)β]
        return Qubit(
            amplitude0: qubit.amplitude0,
            amplitude1: phase * qubit.amplitude1
        )
    }
    
    // MARK: - Composite Gates
    
    /// Square root of X gate
    ///
    /// When applied twice, equals the Pauli-X gate
    ///
    /// Linear Algebra: Matrix square root, √X·√X = X
    /// Corresponds to RX(π/2)
    ///
    /// - Parameter qubit: Input qubit state
    /// - Returns: √X transformed qubit state
    public static func sqrtX(_ qubit: Qubit) -> Qubit {
        return rotationX(qubit, angle: .pi / 2)
    }
    
    /// Square root of Y gate
    ///
    /// When applied twice, equals the Pauli-Y gate
    ///
    /// Linear Algebra: Matrix square root, √Y·√Y = Y
    /// Corresponds to RY(π/2)
    ///
    /// - Parameter qubit: Input qubit state
    /// - Returns: √Y transformed qubit state
    public static func sqrtY(_ qubit: Qubit) -> Qubit {
        return rotationY(qubit, angle: .pi / 2)
    }
    
    /// Identity gate (no operation)
    ///
    /// Returns the qubit unchanged
    ///
    /// Linear Algebra: Identity matrix I = [[1,0],[0,1]]
    /// Neutral element: I·|ψ⟩ = |ψ⟩
    ///
    /// - Parameter qubit: Input qubit state
    /// - Returns: Unchanged qubit state
    public static func identity(_ qubit: Qubit) -> Qubit {
        return qubit
    }
}


// MARK: - Gate Sequences

extension QuantumGates {
    
    /// Applies a sequence of single-qubit gates
    ///
    /// - Parameters:
    ///   - qubit: Initial qubit state
    ///   - gates: Array of gate functions to apply in order
    /// - Returns: Final qubit state after applying all gates
    public static func applySequence(_ qubit: Qubit, gates: [(Qubit) -> Qubit]) -> Qubit {
        return gates.reduce(qubit) { current, gate in
            gate(current)
        }
    }
    
    /// Creates a gate that applies the Hadamard gate n times
    ///
    /// Note: H² = I, so even n gives identity, odd n gives Hadamard
    ///
    /// - Parameter n: Number of times to apply Hadamard
    /// - Returns: Gate function
    public static func hadamardPower(_ n: Int) -> (Qubit) -> Qubit {
        return { qubit in
            if n % 2 == 0 {
                return qubit  // Even power of H is identity
            } else {
                return hadamard(qubit)  // Odd power of H is H
            }
        }
    }
}

// MARK: - Gate Verification

extension QuantumGates {
    
    /// Verifies that a gate preserves the normalization of qubit states
    ///
    /// - Parameters:
    ///   - gate: Gate function to test
    ///   - testCases: Array of test qubits (default: standard test cases)
    /// - Returns: true if all test cases remain normalized after gate application
    public static func verifyUnitarity(
        gate: (Qubit) -> Qubit,
        testCases: [Qubit] = [.zero, .one, .superposition, .random(), .random()]
    ) -> Bool {
        for testCase in testCases {
            let result = gate(testCase)
            if !result.isNormalized {
                return false
            }
        }
        return true
    }
    
    /// Checks if two gates are equivalent (within numerical precision)
    ///
    /// - Parameters:
    ///   - gate1: First gate function
    ///   - gate2: Second gate function
    ///   - tolerance: Numerical tolerance for comparison
    /// - Returns: true if gates produce equivalent results
    public static func areGatesEquivalent(
        _ gate1: (Qubit) -> Qubit,
        _ gate2: (Qubit) -> Qubit,
        tolerance: Double = 1e-14
    ) -> Bool {
        let testCases: [Qubit] = [.zero, .one, .superposition, .random(), .random()]
        
        for testCase in testCases {
            let result1 = gate1(testCase)
            let result2 = gate2(testCase)
            
            if !result1.amplitude0.isApproximatelyEqual(to: result2.amplitude0, tolerance: tolerance) ||
               !result1.amplitude1.isApproximatelyEqual(to: result2.amplitude1, tolerance: tolerance) {
                return false
            }
        }
        return true
    }
}
